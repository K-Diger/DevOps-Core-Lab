# 06. 오픈소스 기여 — 기술 심화 가이드

> **리뷰어 관점**: 1년차가 오픈소스에 기여했다는 것은 단순 기술력이 아니라 **자기주도 학습 능력, 코드 리딩 역량, 글로벌 커뮤니케이션, 엔지니어링 마인드셋**을 동시에 검증할 수 있는 시그널이다. 이력서
> 상단에 배치된 만큼 반드시 깊게 물어볼 수 있다.

---

## 1. 오픈소스 기여 Overview

### 1.1 기여 프로젝트 요약

| 프로젝트            | 저장소                     | 기여 유형            | 핵심 키워드                             |
|-----------------|-------------------------|------------------|------------------------------------|
| Kubernetes Core | `kubernetes/kubernetes` | 소스코드 분석 기반 코드 기여 | Go, kubelet, scheduler, controller |
| Kafka UI        | `provectus/kafka-ui`    | 기능 개선 / 버그 픽스    | Java, Kafka 모니터링, Web UI           |

### 1.2 기여 동기

- **Kubernetes Core**: CKA/CKS 자격증 준비 과정에서 "kubectl이 왜 이렇게 동작하는가?"라는 의문 → 소스코드 직접 분석 → 개선 포인트 발견 → PR 제출
- **Kafka UI**: 실무에서 Kafka 운영 중 모니터링 UI의 불편함 → 직접 개선하여 팀 전체가 혜택을 받는 방향으로 기여

### 1.3 오픈소스 기여가 중요한 이유

1. **코드 리딩 능력 검증**: 수백만 라인의 코드베이스에서 관련 코드를 찾아 이해하는 능력
2. **커뮤니케이션 역량**: 영어로 이슈/PR 작성, 리뷰어와의 기술적 토론
3. **코드 품질 인식**: CI/CD 파이프라인, 린터, 테스트 커버리지 등 높은 기준 경험
4. **자기주도성**: 누가 시키지 않아도 문제를 찾고 해결하는 엔지니어링 마인드셋
5. **기술 깊이**: 블랙박스가 아닌 화이트박스로 도구를 이해하는 역량

---

## 2. 핵심 복기 포인트

### 2.1 Kubernetes Core 기여

#### 어떤 이슈를 해결했는지

- K8s 소스코드 분석(`Go/Kubernetes/` 디렉토리)을 통해 내부 동작 원리를 파악
- kubelet, kube-scheduler, kube-controller-manager 등 핵심 컴포넌트의 코드 흐름 추적
- 분석 과정에서 발견한 개선 포인트(문서 보강, 코드 정리, 엣지 케이스 처리 등)를 PR로 제출

#### 코드 리뷰 과정에서 배운 점

- **K8s 리뷰 체계**: OWNERS 파일 기반 자동 리뷰어 할당, `/lgtm`, `/approve` 봇 커맨드
- **Prow CI**: 자동 테스트, lint, 빌드 검증이 PR 단위로 실행
- **리뷰어 피드백**: Go 코딩 컨벤션, 에러 핸들링 패턴, 테스트 작성 방식 등에 대한 구체적 피드백
- **SIG(Special Interest Group)** 체계 이해: 어떤 변경이 어떤 SIG 소관인지 파악하는 과정

#### 머지까지의 과정

```
이슈 발견 → K8s Slack/GitHub Issue 검색 → 기존 논의 확인
→ Fork & Branch → 코드 수정 + 테스트 작성
→ PR 제출 (DCO sign-off 필수) → Prow CI 통과 확인
→ 리뷰어 피드백 반영 (2~3 라운드) → /lgtm + /approve → 머지
```

### 2.2 Kafka UI 기여

#### 기여 내용

- Kafka 클러스터 모니터링/관리 Web UI 도구(provectus/kafka-ui)에 기능 개선 및 버그 픽스
- 실무에서 직접 사용하면서 느낀 불편함을 개선 포인트로 도출
- Java/React 기반 프로젝트로, 백엔드-프론트엔드 양쪽 기여 가능성

#### 커뮤니티 소통 경험

- GitHub Issue에서 메인테이너와 기술적 논의
- PR 리뷰 과정에서 코드 스타일, 아키텍처 결정에 대한 토론
- 실무 사용 경험을 바탕으로 한 피드백 제공 → 메인테이너의 긍정적 반응

### 2.3 오픈소스 기여와 실무의 연결

| 오픈소스 경험                        | 실무 적용                                     |
|--------------------------------|-------------------------------------------|
| K8s 소스코드 분석 (kubelet syncLoop) | Pod 상태 이상 시 kubelet 로그만으로 근본 원인 파악 가능     |
| K8s scheduler 코드 분석            | Pod Pending 시 scoring/filtering 단계별 디버깅   |
| K8s controller 패턴 이해           | Custom Operator 설계 시 Reconcile Loop 패턴 적용 |
| Kafka UI 소스 분석                 | Kafka Consumer Lag 이상 시 내부 메트릭 수집 로직 이해   |
| 오픈소스 CI/CD 파이프라인 경험            | 사내 CI/CD 파이프라인 품질 게이트 설계에 반영              |
| 코드 리뷰 문화 체험                    | 팀 내 코드 리뷰 문화 정착에 기여                       |

### 2.4 오픈소스 기여 프로세스

```
[1] 이슈 발견
    ├── 실무 사용 중 버그/불편함 발견
    ├── 소스코드 분석 중 개선 포인트 발견
    └── Good First Issue / Help Wanted 라벨 탐색

[2] 사전 조사
    ├── 기존 Issue/PR 검색 (중복 확인)
    ├── 관련 문서/디자인 문서 확인
    └── 커뮤니티 채널(Slack, Discord)에서 논의

[3] 구현
    ├── Fork → Feature Branch 생성
    ├── 코드 수정 + 단위/통합 테스트 작성
    ├── 로컬 CI 검증 (make test, make verify)
    └── 커밋 메시지 컨벤션 준수 + DCO Sign-off

[4] PR 제출 & 리뷰
    ├── PR 템플릿에 맞춰 변경사항 설명
    ├── CI 파이프라인 통과 확인
    ├── 리뷰어 피드백 반영 (보통 2~3 라운드)
    └── 추가 테스트/문서 보완 요청 대응

[5] 머지 & 후속
    ├── /lgtm + /approve → 자동 머지
    ├── 릴리스 노트 반영 확인
    └── 후속 이슈 모니터링
```

---

## 3. 심화 Q&A — 팀 토론 결과

> **채점 기준 공통 사항**: 1년차 지원자에게 기대하는 것은 완벽한 답변이 아니라, **문제를 발견하고 해결하려는 태도**와 **배움의 깊이**다. "그냥 해봤다"가 아닌 "왜 했고, 무엇을 배웠고, 어떻게
> 실무에 연결했는지"가 핵심.

---

### [팀원1: 박준혁 - 인프라] Q1~Q3

> **"K8s 소스코드 분석은 1년차에게 흔치 않은 경험이다. 진짜로 깊이 있게 했는지, 아니면 표면적으로 훑었는지를 구분해야 한다."**

#### Q1. Kubernetes 소스코드를 분석하게 된 계기와, 실무 트러블슈팅에 실제로 도움이 된 사례를 말씀해주세요.

**의도**: 기여의 진정성 확인 + 소스코드 분석이 실무에 실질적 가치를 줬는지 검증

**키포인트**:

1. CKA/CKS 준비 → "이 기능이 내부적으로 어떻게 동작하는가?" 의문 → 소스코드 직접 추적이라는 자연스러운 동기 흐름
2. 특정 트러블슈팅 사례: 예를 들어 Pod가 Pending 상태에서 벗어나지 않을 때, scheduler 소스를 읽어서 Filter/Score 단계의 어떤 플러그인에서 걸리는지 파악한 경험
3. 소스코드 분석 → 문서화(`Go/Kubernetes/`) → 팀 공유라는 체계적 학습 프로세스

**꼬리질문 1**: "K8s 소스코드에서 가장 인상 깊었던 설계 패턴이 있다면?"

**의도**: 단순 코드 읽기 vs. 아키텍처 수준 이해 구분

**키포인트**:

1. **Informer/SharedInformer 패턴**: API Server 부하를 줄이면서 각 컨트롤러에 이벤트를 효율적으로 전달하는 캐싱 메커니즘
2. **Reconcile Loop (Level-triggered vs. Edge-triggered)**: 원하는 상태와 현재 상태를 비교하여 수렴시키는 선언적 패턴의 실제 구현
3. 이러한 패턴이 왜 대규모 분산 시스템에서 중요한지 실무 맥락과 연결하여 설명

**꼬리질문 2**: "kubelet의 syncLoop이 Pod 상태를 어떻게 관리하는지 설명해주세요."

**의도**: 특정 컴포넌트에 대한 구체적 이해도 측정

**키포인트**:

1. kubelet이 여러 소스(API Server, File, HTTP)로부터 Pod 스펙 변경을 수신하는 구조
2. syncLoop 내에서 PLEG(Pod Lifecycle Event Generator)가 컨테이너 런타임 상태를 폴링하여 이벤트를 생성하는 흐름
3. syncPod 함수에서 실제 컨테이너 생성/삭제/업데이트가 발생하는 과정, CRI(Container Runtime Interface) 호출 흐름

---

#### Q2. Kubernetes 컨트롤러의 내부 동작을 설명해주세요. 예를 들어, Deployment를 생성하면 내부적으로 무슨 일이 일어나는지요.

**의도**: K8s 핵심 리소스의 내부 흐름을 소스코드 수준에서 이해하고 있는지 확인

**키포인트**:

1. Deployment Controller → ReplicaSet 생성 → ReplicaSet Controller → Pod 생성이라는 계층적 컨트롤러 체인
2. 각 컨트롤러가 독립적인 Reconcile Loop으로 동작하며, Informer를 통해 관심 리소스의 변경을 감지
3. 이벤트가 Work Queue에 쌓이고, worker goroutine이 순차 처리하는 동시성 제어 구조

**꼬리질문 1**: "Rolling Update 시 maxSurge와 maxUnavailable이 내부적으로 어떻게 처리되나요?"

**의도**: 운영에서 자주 마주치는 배포 전략의 내부 동작 이해

**키포인트**:

1. Deployment Controller가 새 ReplicaSet과 이전 ReplicaSet의 replica 수를 조절하는 로직
2. `deploymentutil.go`의 NewRSNewReplicas 함수에서 maxSurge/maxUnavailable을 계산하는 구체적 로직
3. 비율(%) 지정 시 올림/내림 처리 방식과, 전체 가용 Pod 수가 항상 보장되는 메커니즘

**꼬리질문 2**: "소스코드를 읽을 때 어디서부터 시작하시나요? 수백만 라인에서 원하는 코드를 찾는 본인만의 방법이 있나요?"

**의도**: 대규모 코드베이스 탐색 능력 (실무에서도 중요한 역량)

**키포인트**:

1. 진입점 파악: `cmd/` 디렉토리에서 바이너리별 main 함수 → 초기화 흐름 추적
2. 인터페이스 기반 탐색: Go의 인터페이스 정의를 찾고, 구현체를 역추적하는 방식
3. `grep`, IDE의 "Find Usages", `git log --all -S "함수명"` 등을 활용한 히스토리 기반 코드 고고학

---

#### Q3. K8s 기여 경험이 CKA/CKS 자격증 취득에 어떤 시너지를 줬는지 설명해주세요.

**의도**: 자격증과 실전 경험의 연계를 통한 학습 전략 확인

**키포인트**:

1. CKA 범위의 네트워킹, 스케줄링, 스토리지 등이 소스코드 분석 과정에서 자연스럽게 깊이 이해됨
2. CKS의 보안 정책(PSP→PSA, RBAC, NetworkPolicy 등)을 소스 수준에서 이해하면 "왜 이 설정이 필요한지" 원리를 파악 가능
3. 시험의 트러블슈팅 문제에서 "이 에러가 어떤 컴포넌트의 어떤 로직에서 발생하는지" 바로 추론 가능

**꼬리질문 1**: "소스코드를 몰랐다면 풀지 못했을 CKA/CKS 문제가 있나요?"

**의도**: 구체적 사례를 통한 학습 깊이 확인

**키포인트**:

1. 특정 시험 시나리오에서 에러 로그만으로 원인을 빠르게 파악한 경험
2. 소스코드 이해가 공식 문서에 없는 엣지 케이스 해결에 도움이 된 사례
3. 자격증은 "무엇을 할 수 있는지", 소스 분석은 "왜 그렇게 동작하는지"로 상호 보완

**꼬리질문 2**: "소스코드 분석 자료를 팀에 공유한 적이 있나요? 어떤 반응이었나요?"

**의도**: 지식 공유 문화 기여 의지 확인

**키포인트**:

1. `Go/Kubernetes/` 디렉토리에 체계적으로 문서화한 분석 자료 존재
2. 팀 내 세미나 또는 기술 블로그 포스팅을 통한 공유 경험
3. 동료의 트러블슈팅에 분석 자료가 실제로 활용된 사례

---

### [팀원2: 이서연 - SRE] Q1~Q3

> **"SRE 관점에서 오픈소스 도구의 한계를 파악하고, upstream에 기여할 수 있는 엔지니어는 팀에 큰 자산이다."**

#### Q1. 실무에서 사용하는 오픈소스 도구의 버그나 한계를 어떻게 파악하시나요?

**의도**: 수동적 사용자 vs. 능동적 기여자 구분

**키포인트**:

1. **모니터링 기반 이상 탐지**: 메트릭/로그에서 예상치 못한 패턴 발견 → 도구 자체의 버그인지 설정 문제인지 분류
2. **소스코드 추적**: 의심 영역을 로그 메시지로부터 역추적하여 코드 레벨에서 원인 확인
3. **GitHub Issues/Changelog 모니터링**: 사용 중인 버전의 Known Issues 확인, 새 릴리스의 Breaking Changes 추적

**꼬리질문 1**: "실무에서 오픈소스 도구의 버그를 발견했을 때, 워크어라운드와 upstream 수정 중 어떤 기준으로 선택하나요?"

**의도**: 실용적 판단력 + upstream 기여 경험의 실질적 가치

**키포인트**:

1. **긴급도**: 프로덕션 장애 → 즉시 워크어라운드 적용 → 이후 upstream PR 제출 (양쪽 병행)
2. **영향 범위**: 자사만의 특수 케이스 → 사내 패치, 커뮤니티 공통 이슈 → upstream 기여
3. **유지보수 비용**: 사내 패치가 쌓이면 업그레이드 시 충돌 위험 → upstream 머지가 장기적으로 유리

**꼬리질문 2**: "오픈소스 도구를 업그레이드할 때 어떤 프로세스를 따르시나요?"

**의도**: 운영 안정성과 최신 기능 사이의 균형 감각

**키포인트**:

1. Changelog/Release Notes 분석 → Breaking Changes 식별 → 영향도 평가
2. 스테이징 환경에서 충분한 검증 → 카나리 배포 → 점진적 롤아웃
3. 롤백 계획 수립 + 핵심 메트릭 모니터링 기준 설정

---

#### Q2. upstream 버그 리포트를 작성할 때 어떤 정보를 포함하시나요? 좋은 버그 리포트의 기준은?

**의도**: 커뮤니티 소통 품질 + 문제 분석 역량

**키포인트**:

1. **재현 환경**: OS, K8s 버전, 도구 버전, 관련 설정 파일(민감 정보 제거)
2. **재현 스텝**: 최소한의 재현 시나리오(Minimal Reproducible Example)
3. **Expected vs. Actual**: 기대 동작과 실제 동작의 명확한 차이 + 관련 로그/스크린샷

**꼬리질문 1**: "버그 리포트를 올렸는데 메인테이너가 'Won't Fix'로 닫았다면 어떻게 하시나요?"

**의도**: 커뮤니티 소통에서의 성숙도

**키포인트**:

1. 먼저 Won't Fix 사유를 이해하고, 설계 의도나 우선순위를 존중
2. 비즈니스 임팩트가 크다면 추가 컨텍스트를 정중하게 제공하여 재검토 요청
3. 최종적으로 수용되지 않으면 Fork 유지 또는 대안 도구 검토라는 현실적 판단

**꼬리질문 2**: "영어로 기술적 토론을 하는 것이 어려웠던 적은 없나요? 어떻게 극복했나요?"

**의도**: 글로벌 커뮤니케이션 역량

**키포인트**:

1. 초기에는 기존 PR/Issue의 커뮤니케이션 패턴을 학습하여 템플릿처럼 활용
2. 기술 영어는 일상 영어보다 패턴이 정형화되어 있어 반복 노출로 빠르게 익숙해짐
3. 코드와 로그가 공통 언어 역할 → 기술적 맥락이 명확하면 영어 표현의 한계를 보완 가능

---

#### Q3. SRE 관점에서 오픈소스 기여 경험이 있는 엔지니어와 없는 엔지니어의 차이는 무엇이라고 생각하시나요?

**의도**: 메타인지 — 본인 경험의 가치를 객관적으로 평가할 수 있는지

**키포인트**:

1. **장애 대응 깊이**: "블랙박스 안에서 뭔가 잘못됐다" vs. "이 컴포넌트의 이 로직에서 이 조건일 때 발생한다"
2. **도구 선택 안목**: 소스코드를 읽을 수 있으면 GitHub Star 수가 아닌 코드 품질/아키텍처로 도구를 평가
3. **겸손함 유지**: 과장하지 말 것. "모든 오픈소스를 다 분석하진 않지만, 필요할 때 코드를 직접 읽을 수 있는 역량을 갖추었다"가 좋은 답변

**꼬리질문 1**: "오픈소스 기여 경험이 없는 동료에게 기여를 추천한다면, 어떤 프로젝트부터 시작하라고 하시겠어요?"

**의도**: 멘토링 역량 + 커뮤니티 생태계 이해도

**키포인트**:

1. 본인이 실무에서 매일 사용하는 도구부터 시작 (동기부여 유지)
2. `good-first-issue` 라벨이 잘 관리되고, 메인테이너가 활발한 프로젝트 선택
3. 코드 기여가 아닌 문서 개선/번역부터 시작하면 기여 프로세스에 익숙해지기 좋음

**꼬리질문 2**: "오픈소스 프로젝트의 코드 품질을 어떤 기준으로 평가하시나요?"

**의도**: 소프트웨어 품질 평가 안목

**키포인트**:

1. 테스트 커버리지, CI/CD 파이프라인 성숙도, 릴리스 주기의 안정성
2. 이슈/PR 처리 속도, 메인테이너의 응답 품질, CODEOWNERS/OWNERS 파일 관리 수준
3. 의존성 관리, 보안 패치 대응 속도, 문서화 수준

---

### [팀원3: 최민수 - 보안] Q1~Q2

> **"오픈소스 도입은 곧 서드파티 코드를 프로덕션에 넣는 것이다. 보안 관점의 인식이 있는지 확인해야 한다."**

#### Q1. 오픈소스 도구를 프로덕션에 도입할 때 보안 측면에서 어떤 점을 검토하시나요?

**의도**: 오픈소스 기여자가 보안 인식도 갖추고 있는지 확인

**키포인트**:

1. **Supply Chain Security**: 의존성 트리 분석(SCA), 알려진 CVE 확인, SBOM(Software Bill of Materials) 생성
2. **코드 감사**: 인증/인가 로직, 시크릿 관리 방식, 네트워크 통신 암호화 여부 검토
3. **커뮤니티 건전성**: 보안 이슈 대응 속도, 보안 정책(SECURITY.md) 존재 여부, CVE 할당 프로세스

**꼬리질문 1**: "K8s 생태계에서 최근 발생한 보안 이슈 중 인상 깊었던 것은?"

**의도**: 보안 동향 모니터링 습관 확인

**키포인트**:

1. 구체적 CVE 사례 (예: CVE-2022-3172 aggregated API server SSRF, CVE-2023-5528 Windows node 권한 상승 등)
2. 해당 CVE의 근본 원인이 소스코드 어디에 있었는지 분석
3. 패치 내용과 완화 조치(mitigation)를 소스코드 레벨에서 이해

**꼬리질문 2**: "오픈소스에 기여할 때 보안 취약점을 발견하면 어떻게 처리하나요?"

**의도**: Responsible Disclosure 프로세스 인식 확인

**키포인트**:

1. 보안 취약점은 Public Issue가 아닌 **Private Security Report**(SECURITY.md에 명시된 채널)로 보고
2. K8s의 경우 `security@kubernetes.io`로 리포트, Embargo 기간 준수
3. CVE 할당 → 패치 개발 → 조율된 공개(Coordinated Disclosure) 프로세스 이해

---

#### Q2. 오픈소스 이미지를 프로덕션 K8s 클러스터에서 사용할 때 어떤 보안 조치를 적용하시나요?

**의도**: 컨테이너 보안 실무 역량 + 오픈소스 운영 보안

**키포인트**:

1. **이미지 스캐닝**: Trivy, Grype 등으로 빌드/배포 파이프라인에 취약점 스캔 통합
2. **이미지 서명/검증**: Cosign(Sigstore)을 활용한 이미지 무결성 검증, Admission Controller로 미서명 이미지 차단
3. **최소 권한 원칙**: Non-root 실행, Read-only 파일시스템, SecurityContext/PSA(Pod Security Admission) 적용

**꼬리질문 1**: "Distroless 이미지와 일반 이미지의 차이점과 트레이드오프는?"

**의도**: 컨테이너 보안 심화 이해

**키포인트**:

1. Distroless: 공격 표면 최소화(셸 없음, 패키지 매니저 없음), CVE 수 감소
2. 트레이드오프: 디버깅 어려움 → kubectl debug으로 ephemeral container 사용으로 보완
3. 멀티스테이지 빌드와 조합하여 빌드 환경과 실행 환경 분리

**꼬리질문 2**: "K8s RBAC을 소스코드 수준에서 분석해본 적이 있나요? 인가 흐름이 어떻게 되나요?"

**의도**: CKS + 소스 분석 경험의 교차 검증

**키포인트**:

1. API Server의 Authorization Chain: Node → ABAC → RBAC → Webhook 순서로 평가
2. RBAC Authorizer가 Role/ClusterRole과 RoleBinding/ClusterRoleBinding을 매칭하는 로직
3. `pkg/auth/authorizer/rbac/` 패키지에서 `Authorize()` 함수의 동작 흐름

---

### [팀원4: 김하준 - 플랫폼] Q1~Q3

> **"플랫폼 엔지니어 관점에서, 오픈소스를 잘 고르고 잘 운영하는 것은 핵심 역량이다."**

#### Q1. 같은 카테고리의 오픈소스 도구가 여러 개일 때, 어떤 기준으로 선택하시나요?

**의도**: 기술 선택의 합리성 + 의사결정 프레임워크

**키포인트**:

1. **기능 적합성**: 요구사항 매칭 + PoC(Proof of Concept) 실행
2. **커뮤니티 건전성**: 커밋 빈도, 이슈 응답 시간, 메인테이너 수, CNCF 등 재단 후원 여부
3. **운영 복잡성**: 설치/운영/업그레이드 난이도, 모니터링/로깅 지원, 문서화 수준

**꼬리질문 1**: "Kafka UI를 선택한 이유는? 다른 대안(AKHQ, Conduktor 등)과 비교했나요?"

**의도**: 실제 도구 선택 프로세스의 구체적 사례

**키포인트**:

1. 각 도구의 장단점을 기능/UX/성능/커뮤니티 관점에서 비교한 구체적 기준
2. Kafka UI를 선택한 결정적 이유 (예: React 기반으로 커스터마이징 용이, 가볍고 K8s 친화적 등)
3. 선택 후 실제 사용하면서 검증한 내용과 기여를 통한 개선

**꼬리질문 2**: "CNCF 프로젝트의 Maturity Level(Sandbox, Incubating, Graduated)이 도구 선택에 어떤 영향을 미치나요?"

**의도**: 클라우드 네이티브 생태계 이해도

**키포인트**:

1. Graduated: 프로덕션 레디, 충분한 채택, 보안 감사 완료 (예: K8s, Prometheus, Envoy)
2. Incubating: 활발한 개발, 상당한 채택 (예: Argo, Cilium) → 프로덕션 가능하나 변경사항 주의
3. Sandbox: 초기 단계, 실험적 사용에 적합 → 프로덕션 도입 시 리스크 인지 필요

---

#### Q2. 오픈소스 커뮤니티 활동이 엔지니어의 기술력 향상에 어떤 영향을 미친다고 생각하시나요?

**의도**: 성장에 대한 메타인지 + 커뮤니티 가치관

**키포인트**:

1. **코드 리뷰 문화**: 시니어 메인테이너의 코드 리뷰를 받는 것 자체가 무료 멘토링
2. **설계 사고**: RFC/KEP(K8s Enhancement Proposal) 같은 설계 문서를 읽으면서 아키텍처 의사결정 과정 학습
3. **글로벌 네트워크**: 전 세계 엔지니어와의 기술적 교류, 최신 트렌드 자연스럽게 습득

**꼬리질문 1**: "K8s KEP(Kubernetes Enhancement Proposal)을 읽어본 적이 있나요? 인상 깊었던 KEP은?"

**의도**: K8s 생태계에 대한 깊이 있는 참여도 확인

**키포인트**:

1. 구체적 KEP 번호와 내용 언급 (예: KEP-4639 OCI VolumeSource, KEP-2400 Node Memory Swap 등)
2. KEP의 구조(Motivation, Proposal, Alternatives)에서 배운 설계 문서 작성 방법
3. KEP이 실제 코드로 구현되는 과정을 추적한 경험

**꼬리질문 2**: "오픈소스 기여를 통해 실무에서 직접 도입하거나 변경한 프로세스가 있나요?"

**의도**: 기여 경험의 실무 전이 효과

**키포인트**:

1. K8s 프로젝트의 CI/CD 파이프라인(Prow, Tide)에서 영감을 받은 사내 파이프라인 개선
2. OWNERS 파일 기반 자동 리뷰어 할당 시스템 도입 또는 제안
3. 오픈소스 프로젝트의 이슈 트래킹/문서화 방식을 팀 프로세스에 반영

---

#### Q3. 플랫폼 팀에서 내부 개발 플랫폼(IDP)을 만들 때, 오픈소스 생태계를 어떻게 활용하시겠어요?

**의도**: 플랫폼 엔지니어링 비전 + 오픈소스 활용 전략

**키포인트**:

1. **빌드 vs. 바이(Buy/Adopt)**: Backstage 같은 기존 플랫폼 프레임워크 채택 vs. 자체 구축, 각각의 트레이드오프
2. **조합 전략**: ArgoCD(GitOps) + Crossplane(인프라) + Backstage(포탈) 같은 오픈소스 조합으로 플랫폼 구성
3. **Upstream First 원칙**: 커스터마이징이 필요하면 가능한 upstream에 기여하여 유지보수 부담 최소화

**꼬리질문 1**: "오픈소스를 커스터마이징해서 사용할 때 Fork 유지 비용을 어떻게 관리하시나요?"

**의도**: 실무 운영 감각

**키포인트**:

1. Upstream과의 diff를 최소화하고, 패치를 독립적인 레이어로 관리
2. 정기적으로 upstream 변경사항을 rebase/merge하여 drift 방지
3. 가능한 한 upstream PR로 변환하여 장기적으로 Fork를 제거하는 방향

**꼬리질문 2**: "오픈소스 라이선스(Apache 2.0, MIT, GPL 등)의 차이가 실무 도입에 어떤 영향을 미치나요?"

**의도**: 법적/실무적 리스크 인식

**키포인트**:

1. Permissive(MIT, Apache 2.0) vs. Copyleft(GPL): 상용 서비스에서의 사용 제약 차이
2. Apache 2.0의 특허 조항이 기업 환경에서 선호되는 이유
3. 최근 오픈소스 라이선스 변경 트렌드(BSL, SSPL 등)와 기업에 미치는 영향

---

### [팀원5: 정유진 - CI/CD] Q1~Q2

> **"CI/CD 관점에서 오픈소스 기여 프로세스 자체가 고품질 CI/CD 파이프라인의 축소판이다."**

#### Q1. Kafka UI에 기여하게 된 동기와 전체 과정을 말씀해주세요.

**의도**: 기여의 자연스러운 동기 + 문제 해결 과정의 구체성

**키포인트**:

1. 실무에서 Kafka 운영 중 Kafka UI 사용 → 특정 기능의 불편함/버그 발견
2. 단순 이슈 리포트에 그치지 않고 직접 코드를 분석하여 PR 제출
3. 메인테이너와의 소통 과정, 리뷰 피드백 반영, 최종 머지까지의 타임라인

**꼬리질문 1**: "Kafka UI의 아키텍처를 간략히 설명해주세요. 어떤 기술 스택인가요?"

**의도**: 기여한 프로젝트에 대한 기술적 이해도

**키포인트**:

1. 백엔드: Java/Spring WebFlux (리액티브), Kafka Admin Client API 활용
2. 프론트엔드: React/TypeScript
3. 전체 아키텍처: Kafka 클러스터와의 통신 방식, 토픽/컨슈머 그룹 데이터 수집 흐름

**꼬리질문 2**: "Kafka UI에서 개선한 부분이 다른 사용자에게도 도움이 되었나요? 피드백을 받은 적이 있나요?"

**의도**: 기여의 임팩트 인식

**키포인트**:

1. PR에 달린 다른 사용자의 긍정적 반응이나 관련 이슈의 해결
2. GitHub Star/Fork 수로 볼 수 있는 프로젝트 자체의 영향력
3. 사내 팀원들이 개선된 기능을 사용하면서 얻은 직접적 혜택

---

#### Q2. 오픈소스 프로젝트의 CI/CD 파이프라인에서 인상 깊었던 점이 있나요? 실무에 적용할 수 있는 부분은?

**의도**: CI/CD 전문성 + 오픈소스 경험의 실무 연결

**키포인트**:

1. **K8s의 Prow**: GitHub 이벤트 기반 자동화, `/retest`, `/lgtm` 같은 ChatOps 커맨드
2. **자동화된 품질 게이트**: DCO 체크, lint, unit test, integration test, e2e test가 PR 단위로 자동 실행
3. **릴리스 자동화**: 시맨틱 버저닝, 자동 체인지로그, 릴리스 노트 생성

**꼬리질문 1**: "K8s에서 사용하는 Prow의 동작 원리를 설명해주세요."

**의도**: K8s 개발 인프라에 대한 이해

**키포인트**:

1. Prow: K8s 기반 CI/CD 시스템, GitHub Webhook 이벤트를 수신하여 작업 실행
2. Tide: PR 자동 머지 관리, 머지 조건(라벨, 테스트 통과) 충족 시 자동 머지
3. Deck: Prow 대시보드, 작업 상태/로그 확인. 전체가 K8s 네이티브로 운영됨

**꼬리질문 2**: "오픈소스 프로젝트의 테스트 전략에서 배울 점이 있었나요?"

**의도**: 테스트 문화 인식

**키포인트**:

1. K8s의 테스트 계층: unit → integration → e2e, 각 계층의 목적과 실행 시점 구분
2. 테스트 커버리지를 PR 단위로 체크하는 자동화
3. Flaky 테스트 관리: `[Flaky]` 태그로 분류하고, 전담 팀이 안정화하는 프로세스

---

### [팀원6: 한소윤 - EM(Engineering Manager)] Q1~Q3

> **"EM 관점에서 1년차가 오픈소스에 기여했다는 것은 기술력보다 성장 잠재력의 시그널이다. 어떤 마인드셋으로 접근했는지가 핵심이다."**

#### Q1. 1년차에 Kubernetes Core 같은 대형 프로젝트에 기여를 시작한 동기는 무엇인가요?

**의도**: 성장 동기(내재적 vs. 외재적) + 진정성 확인

**키포인트**:

1. **자연스러운 호기심**: "매일 사용하는 K8s가 내부적으로 어떻게 동작하는지 궁금했다" → 소스코드 분석 → 개선점 발견 → 기여
2. **학습 전략의 일부**: CKA/CKS 준비 + 실무 트러블슈팅 역량 강화의 수단으로 소스 분석 시작
3. **겸손한 태도**: "대단한 기여라기보다, 소스코드를 읽는 과정에서 자연스럽게 발견한 개선점을 반영한 것"

**꼬리질문 1**: "처음 PR을 제출할 때 두려움이 없었나요? 어떻게 극복했나요?"

**의도**: 심리적 장벽 극복 경험 (Growth Mindset)

**키포인트**:

1. 처음에는 "내 코드가 리젝당하면 어떡하지?"라는 부담감 존재
2. 기존 Merged PR들의 패턴을 충분히 학습한 후 시작 → 리젝 리스크 최소화
3. "최악의 경우 배움을 얻는다"는 마인드셋 + 커뮤니티의 환영하는 분위기가 도움

**꼬리질문 2**: "오픈소스 기여가 이력서에 미치는 영향을 인식하고 시작한 건가요, 아니면 순수한 기술적 호기심이었나요?"

**의도**: 동기의 진정성 (이력서 꾸미기 vs. 진짜 성장)

**키포인트**:

1. 솔직하게 답변: "이력서 효과도 인식하고 있었지만, 근본적으로는 기술적 호기심이 먼저였다"
2. 이력서를 위해서만 했다면 지속적으로 하기 어려웠을 것이라는 자기 분석
3. 결과적으로 실무 역량 향상이라는 실질적 가치를 얻었다는 증거 제시

---

#### Q2. 업무와 오픈소스 기여, 자격증 공부를 병행하면서 시간 관리를 어떻게 하시나요?

**의도**: 시간 관리 + 우선순위 설정 + 번아웃 방지 역량

**키포인트**:

1. **우선순위**: 업무 > 자격증(단기 목표) > 오픈소스(장기 성장), 명확한 우선순위 설정
2. **시너지 활용**: CKA 공부 중 소스 분석 → 오픈소스 기여로 이어지는 학습 루프 설계 (별도 시간이 아닌 통합 학습)
3. **지속가능성**: 매일 1시간씩 꾸준히 하는 것이 주말 몰아서 하는 것보다 효과적이라는 인식

**꼬리질문 1**: "번아웃을 경험한 적이 있나요? 어떻게 관리하시나요?"

**의도**: 장기적 성장 지속 가능성

**키포인트**:

1. 번아웃 징후를 인식하고 의식적으로 쉬는 시간 확보
2. 오픈소스 기여를 "해야 할 일"이 아닌 "하고 싶은 일"로 포지셔닝
3. 단기적 성과보다 장기적 역량 성장에 초점을 두는 마인드셋

**꼬리질문 2**: "1년차에 이렇게 많은 것을 병행하는 이유는 무엇인가요? 3년 후 어떤 엔지니어가 되고 싶은 건가요?"

**의도**: 커리어 비전 + 성장 방향성

**키포인트**:

1. 3년차 대기업 이직이라는 구체적 목표 (단, "대기업 간판"이 아닌 "더 큰 규모의 인프라를 다루고 싶다"는 기술적 동기)
2. K8s 소스를 읽을 수 있는 플랫폼 엔지니어 → 장기적으로 K8s 생태계 전문가
3. 오픈소스 기여를 통해 글로벌 엔지니어링 커뮤니티에서 인정받는 엔지니어

---

#### Q3. 팀에 합류하면 오픈소스 기여 경험을 어떻게 활용하시겠어요?

**의도**: 팀 기여 관점 + 조직 적합성

**키포인트**:

1. **트러블슈팅 역량**: K8s 소스코드 이해를 바탕으로 깊이 있는 장애 분석 제공
2. **지식 공유**: 소스코드 분석 자료 공유, 팀 내 "소스 읽기 스터디" 제안
3. **코드 리뷰 문화**: 오픈소스 프로젝트에서 경험한 코드 리뷰 Best Practice를 팀에 전파

**꼬리질문 1**: "팀에서 오픈소스 기여 시간을 공식적으로 보장받지 못한다면 어떻게 하시겠어요?"

**의도**: 현실적 제약 속에서의 태도

**키포인트**:

1. 업무 시간에는 100% 업무에 집중하는 것이 당연
2. 오픈소스 기여가 업무에 직접 도움이 되는 경우(사내 도구 관련)에는 제안 가능
3. 개인 시간에 지속하되, 업무 성과가 기반이 되어야 한다는 인식

**꼬리질문 2**: "오픈소스에서 받은 코드 리뷰 중 가장 기억에 남는 피드백은?"

**의도**: 피드백 수용 능력 + 성장 경험의 구체성

**키포인트**:

1. 구체적인 리뷰 피드백 내용과 그로 인해 바뀐 코딩 습관
2. 리뷰어가 누구였는지(K8s SIG 리드 등)와 그 경험의 가치
3. 피드백을 수용하고 개선한 과정이 성장 마인드셋의 증거

---

## 4. 1년차 오픈소스 기여의 어필 전략

### 4.1 과장하지 않되, 과소평가하지도 않기

| Anti-Pattern        | Best Practice                               |
|---------------------|---------------------------------------------|
| "K8s 핵심 기능을 만들었다" | "K8s 소스를 분석하면서 발견한 개선점을 PR로 기여했다"         |
| "오픈소스 커미터다"       | "K8s 프로젝트에 코드 기여를 했고, 지속적으로 참여하고 있다"      |
| "별것 아닌 수정이었다"     | "작은 수정이지만, 그 과정에서 K8s 내부 구조를 깊이 이해하게 되었다" |

### 4.2 기대되는 답변 프레임

```
[상황] 어떤 맥락에서 기여하게 되었는지
  → CKA 준비 중 소스코드 분석 / 실무 Kafka 운영 중 불편함 발견

[행동] 구체적으로 무엇을 했는지
  → 이슈 분석 → 코드 수정 → 테스트 작성 → PR 제출 → 리뷰 대응

[결과] 어떤 성과가 있었는지
  → PR 머지 + 실무 트러블슈팅 역량 향상 + 팀 지식 공유

[배움] 무엇을 배웠는지
  → 대규모 코드베이스 탐색 능력, 코드 리뷰 문화, 글로벌 커뮤니케이션
```

### 4.3 차별화 포인트 요약

1. **1년차 + 오픈소스 기여**: 경력 대비 높은 자기주도성과 기술적 깊이
2. **K8s Core + Kafka UI**: 인프라(Go) + 미들웨어(Java) 양쪽 기여로 다양한 기술 스택 입증
3. **자격증 + 소스 분석 + 실무 시너지**: 이론(CKA/CKS) + 원리(소스 분석) + 실전(업무)의 삼각 학습 구조
4. **체계적 문서화**: `Go/Kubernetes/` 분석 자료 + 기술 블로그로 학습 과정 증명
5. **성장 잠재력 시그널**: "지금 잘하는 사람"이 아닌 "앞으로 빠르게 성장할 사람"임을 증명

---

## 5. 참고 자료

- [Kubernetes Contributor Guide](https://www.kubernetes.dev/docs/guide/)
- [K8s KEP Process](https://github.com/kubernetes/enhancements/tree/master/keps)
- [Kafka UI GitHub](https://github.com/provectus/kafka-ui)
- [CNCF Project Maturity Levels](https://www.cncf.io/projects/)
- [K8s Security Disclosure](https://kubernetes.io/docs/reference/issues-security/security/)
